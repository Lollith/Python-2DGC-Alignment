import os
from datetime import datetime
from waitress import serve
from flask import Flask, render_template, request, jsonify, send_file, Response
from data_converter import DataConverter
from datetime import datetime
import os
import time
import sys
import docker
from datetime import timedelta
from flask import Flask, render_template, request, jsonify, redirect, url_for
import os
import netCDF4 as nc
from werkzeug.utils import secure_filename
import threading
import shutil
import requests
import webbrowser
from functools import wraps
import docker_manager
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor
# from src import nist_search
import logging
from flask import Flask, jsonify
from flask_httpauth import HTTPBasicAuth
from werkzeug.security import check_password_hash
import nist_engine

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)
nist_engine = nist_engine.NistEngine()

load_dotenv()

app = Flask(__name__)

client = docker.from_env()

nist_executor = ThreadPoolExecutor(max_workers=8)

app.config['MAX_CONTENT_LENGTH'] = 3 * 1024 * 1024 * 1024  # 3GB max file size


# Instances
converter = DataConverter()
compose_manager = docker_manager.create_docker_manager("../docker-compose.yml")
# nist_wrapper = nist_search.NISTSearchWrapper()


@app.route('/')
def index():
    """Page principale avec le formulaire."""
    return render_template('index.html',
                           default_input_path=converter.default_path_input,
                           default_output_path=converter.default_path_output)



######## NIST Search Endpoints ########

@app.route('/nist/health', methods=['GET'])
def nist_health():
    """VÃ©rification NIST disponible"""
    return jsonify({
        'nist_status': 'available',
        'timestamp': time.time(),
        'active_threads': len(nist_executor._threads) if hasattr(nist_executor, '_threads') else 0
    })




@app.route('/nist/search', methods=['POST'])
def nist_search():
    """
    Endpoint Flask pour un spectre unique.
    """
    try:
        data = request.json
        if not data or "mass" not in data or "intensity" not in data:
            return jsonify({"error": "Spectre invalide"}), 400

        logger.info("Recherche NIST pour un spectre")

        result = nist_engine.search(data)
        # return jsonify({"hits": result[0]["hits"]})
        return jsonify({"hits": result})

    except Exception as e:
        logger.error(f"Erreur NIST search: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/routes', methods=['GET'])
def list_routes():
    routes = []
    for rule in app.url_map.iter_rules():
        routes.append({
            'endpoint': rule.endpoint,
            'methods': list(rule.methods),
            'route': str(rule)
        })
    return jsonify(routes)


if __name__ == '__main__':

    # Augmenter la limite de rÃ©cursion si nÃ©cessaire
    sys.setrecursionlimit(10000)

    # Configuration Flask pour gros fichiers
    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0
    #TODO pour prod:
    # app.config['SEND_FILE_MAX_AGE_DEFAULT'] = timedelta(days=365)
    #TODO a mettre sur false en prod
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    
    # print("ğŸš€ Serveur Flask dÃ©marrÃ©")
    # print("ğŸ“ Dossier d'upload:", app.config['UPLOAD_FOLDER'])
    # print("ğŸ’¾ Dossier de sortie:", app.config['OUTPUT_FOLDER'])
    # print("âš ï¸  Limite de taille fichier: 3GB")
    # print("ğŸŒ AccÃ©dez Ã : http://localhost:5000")


    if len(sys.argv) > 1 and sys.argv[1] == 'dev':
        print("ğŸš€ Serveur Flask dÃ©marrÃ© en mode dev")
        print("âš ï¸  Limite de taille fichier: 3GB")
        print("ğŸŒ AccÃ©dez Ã : http://localhost:5000")
        app.run(debug=True, host='0.0.0.0', port=5000)
    else:
        print("ğŸš€ Serveur Flask dÃ©marrÃ©")
        print("ğŸš€ DÃ©marrage du serveur en mode production...")
        print("âš ï¸  Limite de taille fichier: 3GB")
        print("ğŸ“ Serveur accessible sur: http://localhost:8080")
        serve(app, host='0.0.0.0', port=8080)
