import os
from datetime import datetime
from waitress import serve
from flask import Flask, render_template, request, jsonify, send_file, Response
from data_converter import DataConverter
from datetime import datetime
import os
import time
import sys
import docker
from datetime import timedelta
from flask import Flask, render_template, request, jsonify, redirect, url_for
import os
import netCDF4 as nc
from werkzeug.utils import secure_filename
import threading
import shutil
import requests
import webbrowser
from functools import wraps
import docker_manager
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor
# from src import nist_search
import logging
from flask import Flask, jsonify
from flask_httpauth import HTTPBasicAuth
from werkzeug.security import check_password_hash
import nist_engine

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)
nist_engine = nist_engine.NistEngine()

load_dotenv()

app = Flask(__name__)

client = docker.from_env()

nist_executor = ThreadPoolExecutor(max_workers=8)

app.config['MAX_CONTENT_LENGTH'] = 3 * 1024 * 1024 * 1024  # 3GB max file size


# Instances
converter = DataConverter()
compose_manager = docker_manager.create_docker_manager("../docker-compose.yml")
# nist_wrapper = nist_search.NISTSearchWrapper()


@app.route('/')
def index():
    """Page principale avec le formulaire."""
    return render_template('index.html',
                           default_input_path=converter.default_path_input,
                           default_output_path=converter.default_path_output)



######## NIST Search Endpoints ########

@app.route('/nist/health', methods=['GET'])
def nist_health():
    """Vérification NIST disponible"""
    return jsonify({
        'nist_status': 'available',
        'timestamp': time.time(),
        'active_threads': len(nist_executor._threads) if hasattr(nist_executor, '_threads') else 0
    })




@app.route('/nist/search', methods=['POST'])
def nist_search():
    """
    Endpoint Flask pour un spectre unique.
    """
    try:
        data = request.json
        if not data or "mass" not in data or "intensity" not in data:
            return jsonify({"error": "Spectre invalide"}), 400

        logger.info("Recherche NIST pour un spectre")

        result = nist_engine.search(data)
        # return jsonify({"hits": result[0]["hits"]})
        return jsonify({"hits": result})

    except Exception as e:
        logger.error(f"Erreur NIST search: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/routes', methods=['GET'])
def list_routes():
    routes = []
    for rule in app.url_map.iter_rules():
        routes.append({
            'endpoint': rule.endpoint,
            'methods': list(rule.methods),
            'route': str(rule)
        })
    return jsonify(routes)


if __name__ == '__main__':

    # Augmenter la limite de récursion si nécessaire
    sys.setrecursionlimit(10000)

    # Configuration Flask pour gros fichiers
    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0
    #TODO pour prod:
    # app.config['SEND_FILE_MAX_AGE_DEFAULT'] = timedelta(days=365)
    #TODO a mettre sur false en prod
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    
    # print("🚀 Serveur Flask démarré")
    # print("📁 Dossier d'upload:", app.config['UPLOAD_FOLDER'])
    # print("💾 Dossier de sortie:", app.config['OUTPUT_FOLDER'])
    # print("⚠️  Limite de taille fichier: 3GB")
    # print("🌐 Accédez à: http://localhost:5000")


    if len(sys.argv) > 1 and sys.argv[1] == 'dev':
        print("🚀 Serveur Flask démarré en mode dev")
        print("⚠️  Limite de taille fichier: 3GB")
        print("🌐 Accédez à: http://localhost:5000")
        app.run(debug=True, host='0.0.0.0', port=5000)
    else:
        print("🚀 Serveur Flask démarré")
        print("🚀 Démarrage du serveur en mode production...")
        print("⚠️  Limite de taille fichier: 3GB")
        print("📍 Serveur accessible sur: http://localhost:8080")
        serve(app, host='0.0.0.0', port=8080)
